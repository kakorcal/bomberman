// Phaser concept:

// States:
//   Boot - general game settings are defined, and the assets of the preloading screen are loaded (example the loading bar). Nothing is shown to the user.

//   Preload - game assets (sprites, audio, json) are loaded. 

//   MainMenu - Welcome screen

//   Game - Actual start of game


  // this.game.time.events.add(2000, function(){
  //   this.bomb.destroy();
  //   this.droponce = true;
  // }, this);
  // this.bomb.destroy();


  // var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create });

  // function preload() {    
  //   game.load.atlas('seacreatures', 'assets/sprites/seacreatures_json.png', 'assets/sprites/seacreatures_json.json'); 
  //   game.load.image('undersea', 'assets/pics/undersea.jpg');    
  //   game.load.image('coral', 'assets/pics/seabed.png');}
  // function create() {    
  //   game.add.sprite(0, 0, 'undersea');    //  Here we create our group and populate it with 6 sprites    
  //   var group = game.add.group();    
  //   for (var i = 0; i < 6; i++){        
  //     //  They are evenly spaced out on the X coordinate, with a random Y coordinate      
  //     sprite = group.create(120 * i, game.rnd.integerInRange(100, 400), 'seacreatures', 'octopus0000');   
  //   }   
  //    //  These are the frame names for the octopus animation. We use the generateFrames function to help create the array.    
  //    var frameNames = Phaser.Animation.generateFrameNames('octopus', 0, 24, '', 4);    
  //    //  Here is the important part. Group.callAll will call a method that exists on every child in the Group.    
  //    //  In this case we're saying: child.animations.add('swim', frameNames, 30, true, false)    
  //    //  The second parameter ('animations') is really important and is the context in which the method is called.    
  //    //  For animations the context is the Phaser.AnimationManager, which is linked to the child.animations property.    
  //    //  Everything after the 2nd parameter is just the usual values you'd pass to the animations.add method.    
  //    group.callAll('animations.add', 'animations', 'swim', frameNames, 30, true, false);    
  //    //  Here we just say 'play the swim animation', this time the 'play' method exists on the child itself, so we can set the context to null.    
  //    group.callAll('play', null, 'swim');    
  //    game.add.sprite(0, 466, 'coral');
  //  }


    // this.bombFrames = Phaser.Animation.generateFrameNames("Bomb_f", 1, 3, ".png", 2);
    // this.flameFrames = Phaser.Animation.generateFrameNames("Flame_F", 0, 4, ".png", 2);


   // this.bombs.callAll(
   //   "animations.add", "animations", "dropbomb", 
   //   this.bombFrames, 2, false, false
   // );

      // this.bombs.callAll("play", null, "dropbomb");


      // this.flame1 = this.flames.create(bombX, bombY, "sprites", "Flame_f00.png");
      // this.flame1.width = 40;
      // this.flame1.height = 40;
      // this.flame1.animations.add(
      //   "explode1",
      //   ["Flame_f00.png", "Flame_f01.png", "Flame_F02.png", "Flame_F03.png", "Flame_F04.png", 
      //    "Flame_f00.png", "Flame_f01.png", "Flame_F02.png", "Flame_F03.png", "Flame_F04.png"],
      //   20, false, false
      // );
      // this.flame1.animations.play("explode1");

      // // Destroy flame after animation loop completes
      // this.flame1.events.onAnimationComplete.add(function(){
      //   this.flame1.destroy();
      //   console.log("flame animation complete");
      // }, this);
      // 

      // if(bmanY === 50){
      //   this.bman.position.y = 40;
      // }
      // if(bmanY >= 110 && bmanY <= 130){
      //   this.bman.position.y = 120;
      // }



      // if(bmanX === 50){
      //   this.bman.position.x = 40;
      // }
      // if(bmanX >= 110 && bmanX <= 130){
      //   this.bman.position.x = 120;
      // }






      // $(document).ready(function(){
      //   var body = $("body");
      //   var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });
      //   var me, players,cursor;

      //   function preload(){
      //     game.load.atlasJSONHash("sprites", "assets/json/sprites.png", "assets/json/sprites.json");

      //     // $.ajax({
      //     //    url: "https://api.iconfinder.com/v2/icons/search?query=cat&count=100&style=&vector=0&premium=0&license=commercial-nonattribution",
      //     //    method: "GET",
      //     //    dataType: "json"
      //     //  }).done(function(data){
      //     //    var imgs = data.icons.map(function(cur){
      //     //      return cur.raster_sizes.filter(function(img){
      //     //        return img.size === 48;
      //     //      });
      //     //    }).filter(function(cur){
      //     //        return cur.length !== 0;
      //     //    });
      //     //    if(data.icons.length === 0 || imgs.length === 0){
      //     //      var error = $("<h1>No search results found</h1>");
      //     //      body.append(error);
      //     //    }else{
      //     //      var srcs = imgs.map(function(cur){
      //     //        return cur[0].formats[0].preview_url;
      //     //      });
      //     //      srcs.forEach(function(cur){
      //     //        var img = $("<img src=" + cur + ">");
      //     //        body.append(img);
      //     //      });
      //     //    }
      //     //    console.log(data);
      //     //    console.log(imgs);
      //     //    console.log(srcs);
      //     //  }).fail(function(msg){
      //     //    alert(msg.responseText);
      //     // });
      //   }

      //   function create(){

      //     // game.add.sprite(0,0,"sprites", "Front/Bman_F_f01.png");



      //     // game.add.sprite(0,0,"sprites", "SolidBlock.png");
      //    // //  We're going to be using physics, so enable the Arcade Physics system
      //     game.physics.startSystem(Phaser.Physics.ARCADE);

      //     players = game.add.group();
      //     // players.enableBody = true;
      //     me = players.create(0,0,"sprites","Front/Bman_F_f01.png");

      //     // var enemy1 = players.create(game.world.width-44, 0, "sprites", "Front/Creep_F_f01.png");
      //     // var enemy2 = players.create(0, game.world.height-44, "sprites", "Front/Creep_F_f01.png");
      //     // var enemy3 = players.create(game.world.width-44, game.world.height-44, "sprites", "Front/Creep_F_f01.png");

      //    // //  A simple background for our game
      //    // game.add.sprite(0, 0, 'sky');

      //    // //  The platforms group contains the ground and the 2 ledges we can jump on
      //    // platforms = game.add.group();

      //    // //  We will enable physics for any object that is created in this group
      //    // platforms.enableBody = true;

      //    // // Here we create the ground.
      //    // var ground = platforms.create(0, game.world.height - 64, 'ground');

      //    // //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
      //    // ground.scale.setTo(2, 2);

      //    // //  This stops it from falling away when you jump on it
      //    // ground.body.immovable = true;

      //    // //  Now let's create two ledges
      //    // var ledge = platforms.create(400, 400, 'ground');

      //    // ledge.body.immovable = true;

      //    // ledge = platforms.create(-150, 250, 'ground');

      //    // ledge.body.immovable = true;

      //    // // The player and its settings
      //    // player = game.add.sprite(32, game.world.height - 150, 'dude');

      //    // //  We need to enable physics on the player
      //    game.physics.arcade.enable(me, Phaser.Physics.ARCADE);

      //    // //  Player physics properties. Give the little guy a slight bounce.
      //    me.body.collideWorldBounds = true;

      //    // //  Our two animations, walking left and right.
      //    // player.animations.add('left', [0, 1, 2, 3], 10, true);
      //    // player.animations.add('right', [5, 6, 7, 8], 10, true);

      //    // stars = game.add.group();

      //    // stars.enableBody = true;

      //    // //  Here we'll create 12 of them evenly spaced apart
      //    // for (var i = 0; i < 12; i++)
      //    // {
      //    //     //  Create a star inside of the 'stars' group
      //    //     var star = stars.create(i * 70, 0, 'star');

      //    //     //  Let gravity do its thing
      //    //     star.body.gravity.y = 6;

      //    //     //  This just gives each star a slightly random bounce value
      //    //     star.body.bounce.y = 0.7 + Math.random() * 0.2;
      //    // }

      //    // scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
      //   }

      //   function update(){
      //     // //  Collide the player and the stars with the platforms
      //     // game.physics.arcade.collide(player, platforms);

      //     cursors = game.input.keyboard.createCursorKeys();
      //     //  Reset the players velocity (movement)
      //         me.body.velocity.x = 0;
      //         me.body.velocity.y = 0;

      //         if(cursors.left.isDown){
      //             //  Move to the left
      //             me.body.velocity.x = -200;
      //             // me.animations.play('left');
      //         }else if(cursors.right.isDown){
      //             //  Move to the right
      //             me.body.velocity.x = 200;
      //             // me.animations.play('right');
      //         }else if(cursors.up.isDown){
      //             me.body.velocity.y = -200;
      //             // players.frame = 4;
      //         }else if(cursors.down.isDown){
      //             me.body.velocity.y = 200;
      //         }else{
      //             //  Stand still
      //             me.animations.stop();         
      //         }

      //         //  Allow the players to jump if they are touching the ground.
      //         // if (cursors.up.isDown && players.body.touching.down)
      //         // {
      //         //     players.body.velocity.y = -350;
      //         // }

      //     //   // game.physics.arcade.collide(stars, platforms);
      //     //   // game.physics.arcade.overlap(player, stars, collectStar, null, this);
      //   }


      // });


      // audios

      // <!--   <audio class="stage" src="http://66.90.91.26/ost/kirby-s-block-ball/wzngaiosgm/bonus-game.mp3" loop></audio> -->

      // Stage Songs + Title
      // http://66.90.91.26/ost/kirby-s-block-ball/wzngaiosgm/bonus-game.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/afsbfzxhvk/mr.-frosty-s-stage-.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/vcfhreavjt/title.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/gayjdnbikx/round-clear.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/npxhnsdibj/poppy-bros.-sr.-s-stage-.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/jushyawlhv/a-life-lost.mp3
      // http://66.90.91.26/ost/kirby-s-block-ball/mimpdbovan/mr.-shine-and-mr.-bright-s-stage-.mp3

      // http://downloads.khinsider.com/game-soundtracks/album/kirby-s-block-ball

      // Sound fx
      // <audio src="assets/audio/boss_hit.wav" autoplay loop>player death</audio>
      // <audio src="assets/audio/explode1.wav" autoplay loop>bomb explode</audio>


      // Explosion tiles near Bomberman
      // var bmanTilePositions = this.explosionLayer.getTiles(bmanX, bmanY, 40, 40, false, false);


      // if(this.game.rnd.integerInRange(0,10) === 1){
      //   this.enemy1.body.velocity.x--;
      //   this.enemy1.animations.play("moveleft");
        // check if still in same position



        // else if(this.game.rnd.integerInRange(0,500) === 1){
        //   this.enemy1.body.velocity.x++;
        //   this.enemy1.animations.play("moveRight");
        // }

        // if(this.game.rnd.integerInRange(0,500) === 1){
        //   this.enemy1.body.velocity.y--;
        //   this.enemy1.animations.play("moveforward");
        // }else if(this.game.rnd.integerInRange(0,500) === 1){
        //   this.enemy1.body.velocity.y++;
        //   this.enemy1.animations.play("moveback");
        // }



        // if(this.game.rnd.integerInRange(0,500) === 1 && this.droponce[2]){
        //   var enemy2X = Math.floor(Math.round(this.enemy2.position.x / 10) * 10);
        //   var enemy2Y = Math.floor(Math.round(this.enemy2.position.y / 10) * 10);
        //   var enemy2TilePositions = this.explosionLayer.getTiles(enemy2X, enemy2Y, 40, 40, false, false);
        //   if(enemy2TilePositions.length === 1){
        //     this.dropBomb(enemy2TilePositions[0].worldX, enemy2TilePositions[0].worldY, 1);
        //   }else{
        //     this.dropBomb(enemy2TilePositions[1].worldX, enemy2TilePositions[1].worldY, 1);        
        //   }
        //   this.droponce[2] = false;
        // }  

        // if(this.game.rnd.integerInRange(0,500) === 1 && this.droponce[3]){
        //   var enemy3X = Math.floor(Math.round(this.enemy3.position.x / 10) * 10);
        //   var enemy3Y = Math.floor(Math.round(this.enemy3.position.y / 10) * 10);
        //   var enemy3TilePositions = this.explosionLayer.getTiles(enemy3X, enemy3Y, 40, 40, false, false);
        //   if(enemy3TilePositions.length === 1){
        //     this.dropBomb(enemy3TilePositions[0].worldX, enemy3TilePositions[0].worldY, 1);
        //   }else{
        //     this.dropBomb(enemy3TilePositions[1].worldX, enemy3TilePositions[1].worldY, 1);        
        //   }
        //   this.droponce[3] = false;
        // }  



constructor: function(){ 
  this.ready = false; 
},        
preload: function(){                                 
this.game.load.atlasJSONHash( "textureKey", "/path.to.image.file", textureJSON );            this.game.load.audio("soundKey", "/path.to.audio.file"); // media/main.mp3                   },        
update: function(){            
  if(this.cache.isSoundDecoded("soundKey") && this.ready === false){                
    this.ready = true;                
    this.state.start('menu');            
  }        
}   











